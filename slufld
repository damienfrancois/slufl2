#! /usr/bin/python3.9
# -*- coding: utf-8 -*-
# The sheband is re-hardcoded by rpmbuild so better 
# to hardcode it here also

import os
import sys
import six
import glob
import json
import time
import yaml
import ldap
import signal
import pprint
import logging
import argparse
import configparser as ConfigParser
from io import StringIO ## for Python 3
from datetime import datetime


__version__ = "3.0.0"

DATE_DATE_FMT = "%Y-%m-%d"
LDAP_DATE_FMT = "%Y%m%d%H%M%S+0100"
LOG_FMT = "%(asctime)s %(filename)s [%(process)s] : %(message)s"
CFG_PID_FILE = '/var/run/slufld.pid'
CFG_LOG_FILE = '/var/log/slufld.log'


def parse_options():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-1", "--run-once", action="store_true", dest="RUNONCE",
        help="Stop after first iteration")
    parser.add_argument(
        "-V", "--version", action="store_true", dest="VERSION",
        help="Show version")
    parser.add_argument(
        "-v", "--verbose", action="store_true", dest="VERBOSE",
        help="Set more verbose output")
    parser.add_argument(
        "-d", "--debug", action="store_true", dest="DEBUG",
        help="Show debugging information")
    parser.add_argument(
        "-n", "--dry-run", action="store_true", dest="DRYRUN",
        help="Show what would be done but do not do it.")
    parser.add_argument(
            "-r", "--from-date", action="store", dest="date",
            type=str, default="",
            help="Reload LDAP entries from given date (YYYY-MM-DD)")
    parser.add_argument(dest="filter", type=str, nargs='?', default="")
    return parser.parse_args()


def parse_config(CFG_FILE):
    try:
        logging.info("Reading configuration file: %s" % CFG_FILE)
        CFG = ConfigParser.RawConfigParser()
        CFG.read(CFG_FILE)
    except KeyError as err:
        logging.critical("FATAL: Config file: Mandatory option(s) missing.")
        sys.exit(-1)
    except ConfigParser.NoSectionError as err:
        logging.critical("FATAL: Config file: Section missing " + err.message)
        sys.exit(-1)
    return CFG



def sig_term(signum, frame):
    logging.warning('SIGTERM recieved, exiting.')
    os.remove(CFG_PID_FILE)
    sys.exit(0)


def sig_hup(signum, frame):
    logging.warning('SIGHUP recieved.')


def build_filter():
    ldap_filter = CFG.get("LDAP", "filter")
    logging.debug("Base filter: %s" % ldap_filter)

    if OPT.filter:
        ldap_filter = "(%s)" % (OPT.filter)
        logging.info("Filter set from argument: %s", ldap_filter)
        return ldap_filter
    else:
        today = datetime.today().strftime(LDAP_DATE_FMT)
        if OPT.date:
            from_date = datetime.strptime(OPT.date, DATE_DATE_FMT).\
                    strftime(LDAP_DATE_FMT)
            logging.debug("Filter set from --date")
        elif os.path.isfile(CFG.get("DAEMON", 'statefile')):
            from_date = open(CFG.get("DAEMON", 'statefile'), 'r').\
                    readline().strip()
            logging.debug("Filter set from statefile %s" %
                          CFG.get("DAEMON", 'statefile'))
        else:
            from_date = today
            logging.warning("WARNING: No state file found. Filter set to now")
        f = "(!(modifyTimestamp=%s))(modifyTimestamp>=%s)(!(expirationDate=%s))(expirationDate>=%s)" %\
            (from_date, from_date, today, today)
        ldap_filter = "(&(%s)%s)" % (ldap_filter, f)
        logging.info("Filter set from date: %s" % ldap_filter)
        return ldap_filter


def poll_ldap():
    logging.info('Connect to ldap server : %s' % CFG.get("LDAP", "uri"))
    logging.info('Bind DN : %s' % CFG.get("LDAP", "binddn"))

    try:
        f = build_filter()
        ldapserver = ldap.initialize(CFG.get("LDAP", "uri"))
        ldapserver.bind(CFG.get("LDAP", "binddn"),
                        CFG.get("LDAP", "credentials"))
        result = ldapserver.search_s(CFG.get("LDAP", "subtree"),
                                     ldap.SCOPE_SUBTREE,
                                     f, ["*", "+"])
        logging.info('Number of entries found: %d.' % len(result))
    except ldap.FILTER_ERROR:
        logging.critical('FATAL: Connect failed: Filter incorrect')
        raise
    except ldap.NO_SUCH_OBJECT:
        logging.critical('FATAL: Connect failed: Subtree not correct')
        raise
    except ldap.LDAPError as error:
        logging.critical('FATAL: Connect failed: %s' % error[0]["desc"])
        raise
    except KeyError:
        logging.critical('FATAL: Connect failed: invalid RootDN or Credential')
        raise
    return result, len(result)


def clean_playbook_retry_files(playbook_dir):
    for file in glob.glob(playbook_dir + "/*.retry"):
        os.remove(file)


def build_playbook_list(playbook_dir):
    playbook_paths = []
    for playbook_path in glob.glob(playbook_dir + "/*.yml"):
        playbook = yaml.load(open(playbook_path).read(), Loader=yaml.FullLoader)
        rank = 0
        desc = playbook_path
        for var in playbook[0]["vars"]:
            print(list(var.items())[0])
            k, v = list(var.items())[0]
            if k == "rank":
                rank = v
            if k == "desc":
                desc = v
            if k == "enable":
                if v:
                    playbook_paths.append((rank, playbook_path, desc))
    return sorted(playbook_paths)


def build_playbook_options():
    loader = DataLoader()
    if C.DEFAULT_VAULT_PASSWORD_FILE:
        vault_secrets = CLI.setup_vault_secrets(
                loader,
                vault_ids=C.DEFAULT_VAULT_IDENTITY_LIST,
                vault_password_files=[C.DEFAULT_VAULT_PASSWORD_FILE],
                auto_prompt=False)
        loader.set_vault_secrets(vault_secrets)
    inventory = Inventory(loader=loader,
                          sources=[CFG.get("ANSIBLE", "inventory")])
    passwords = {}
    return {"variable_manager": None, "loader": loader,
            "inventory": inventory, "passwords": passwords}


def set_cliargs(extra_vars, playbook_options):
    context.CLIARGS = ImmutableDict(
        listtags=False, listtasks=False, listhosts=False,
        syntax=False, connection='ssh', module_path=None, forks=10,
        remote_user='root', private_key_file=None, ssh_common_args=None,
        ssh_extra_args=None, sftp_extra_args=None, scp_extra_args=None,
        become=True, become_method='sudo', become_user='root', verbosity=3,
        check=OPT.DRYRUN, diff=True,
        extra_vars=[json.dumps(extra_vars)], start_at_task=None)
    playbook_options['variable_manager'] = VariableManager(loader=playbook_options['loader'], inventory=playbook_options['inventory'])
    return playbook_options


def run_playbook(playbook_path, playbook_options):
    pbex = PlaybookExecutor(playbooks=[playbook_path], **playbook_options)
    sys_stdout = sys.stdout
    sys.stdout = StringIO()
    rc = pbex.run()
    stdout = sys.stdout.getvalue()
    sys.stdout = sys_stdout
    return rc, stdout


if __name__ == "__main__":

    OPT = parse_options()
    if OPT.VERSION:
        print("Slufl version %s" % __version___)
        sys.exit(-1)

    logging_options = {}
    logging_options["format"] = LOG_FMT
    logging_options["level"] = logging.WARNING
    if OPT.VERBOSE:
        logging_options["level"] = logging.INFO
    if OPT.DEBUG:
        logging_options["level"] = logging.DEBUG
        logging_options["format"] = ""
    logging.basicConfig(**logging_options)

    if OPT.DRYRUN:
        logging.warning("WARNING: Dry-run mode enabled.")

    CFG_FILE = os.environ.get("SLUFL_CFG_FILE") or '/etc/slufld.conf'
    if not os.path.isfile(CFG_FILE):
        logging.critical("FATAL: Configuration file %s not found." % CFG_FILE)
        sys.exit(-1)
    if os.stat(CFG_FILE).st_mode & 1:
        logging.critical("FATAL: Wrong permissions on %s." % CFG_FILE)
        sys.exit(-1)

    CFG = parse_config(CFG_FILE)

    # The Ansible API does not seem to enable the configuration
    # of the path to the configuration file so need to resort
    # to setting the ANSIBLE_CONFIG environment variable.
    if not os.environ.get("ANSIBLE_CONFIG"):
        os.environ["ANSIBLE_CONFIG"] = CFG.get("ANSIBLE", "configfile")

    # The following imports requirement the env to be set
    from ansible.module_utils.common.collections import ImmutableDict
    from ansible.inventory.manager import InventoryManager as Inventory
    from ansible.vars.manager import VariableManager
    from ansible.parsing.dataloader import DataLoader
    from ansible.executor.playbook_executor import PlaybookExecutor
    from ansible import context
    from ansible import constants as C
    from ansible.cli import CLI

    sleeptime = CFG.getint("DAEMON", "initsleeptime")

    PLAYBOOK_DIR = os.environ.get("SLUFL_CONF_DIR") or '/etc/slufld.conf.d'
    playbook_paths = build_playbook_list(PLAYBOOK_DIR)
    playbook_options = build_playbook_options()
    clean_playbook_retry_files(PLAYBOOK_DIR)

    while True:
        try:
            entries, nbentries = poll_ldap()
            for number, (dn, entry) in enumerate(entries):
                logging.warning("Processing item '%s' (%d/%d)" %
                                (entry[CFG.get("LDAP", "logfield")][0].decode(),
                                    number + 1, nbentries))
                for k, v in entry.items():
                    for i, _ in enumerate(v):
                        entry[k][i] = entry[k][i].decode('utf-8')
                logging.debug(pprint.pformat(entry))
                playbook_options = set_cliargs(entry, playbook_options)
                for _, playbook_path, desc in playbook_paths:
                    logging.info("  " + desc)
                    rc, stdout = run_playbook(playbook_path, playbook_options)
                    logging.debug(stdout)
                    if rc > 0:
                        logging.error(stdout)
                        raise Exception()

                if not OPT.RUNONCE:
                    logging.debug("Updating state file (%s)" %
                                  entry["modifyTimestamp"][0])
                    open(CFG.get("DAEMON", "statefile"), 'w').write(
                            entry["modifyTimestamp"][0])

            sleeptime = CFG.getint("DAEMON", "initsleeptime")

        except Exception as err:
            if OPT.RUNONCE:
                logging.critical("ERROR: Problem encountered... Bailing out.")
                raise
            else:
                sleeptime = min(CFG.getint("DAEMON", "maxsleeptime"),
                                sleeptime * 2)
                logging.error('ERROR: Problem encoutered. Will try again "\
                        "in %d seconds...' % sleeptime)
                logging.error('ERROR: Run slufld in debug mode for details.')
                logging.debug(err)

        if OPT.RUNONCE:
            logging.info("All done.")
            logging.warning("Bailing out.")
            break
        else:
            logging.info("Sleeping %d second" % sleeptime)
            time.sleep(sleeptime)
